// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: StatusData.proto

#ifndef PROTOBUF_StatusData_2eproto__INCLUDED
#define PROTOBUF_StatusData_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "StaticData.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_StatusData_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[4];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsPlayerStatusImpl();
void InitDefaultsPlayerStatus();
void InitDefaultsGameStatusImpl();
void InitDefaultsGameStatus();
void InitDefaultsTeamDepthImpl();
void InitDefaultsTeamDepth();
void InitDefaultsGlobalStateImpl();
void InitDefaultsGlobalState();
inline void InitDefaults() {
  InitDefaultsPlayerStatus();
  InitDefaultsGameStatus();
  InitDefaultsTeamDepth();
  InitDefaultsGlobalState();
}
}  // namespace protobuf_StatusData_2eproto
namespace fantasybit {
class GameStatus;
class GameStatusDefaultTypeInternal;
extern GameStatusDefaultTypeInternal _GameStatus_default_instance_;
class GlobalState;
class GlobalStateDefaultTypeInternal;
extern GlobalStateDefaultTypeInternal _GlobalState_default_instance_;
class PlayerStatus;
class PlayerStatusDefaultTypeInternal;
extern PlayerStatusDefaultTypeInternal _PlayerStatus_default_instance_;
class TeamDepth;
class TeamDepthDefaultTypeInternal;
extern TeamDepthDefaultTypeInternal _TeamDepth_default_instance_;
}  // namespace fantasybit
namespace fantasybit {

enum PlayerStatus_Status {
  PlayerStatus_Status_ACTIVE = 0,
  PlayerStatus_Status_INACTIVE = 1,
  PlayerStatus_Status_OTHER = 3,
  PlayerStatus_Status_FA = 4
};
bool PlayerStatus_Status_IsValid(int value);
const PlayerStatus_Status PlayerStatus_Status_Status_MIN = PlayerStatus_Status_ACTIVE;
const PlayerStatus_Status PlayerStatus_Status_Status_MAX = PlayerStatus_Status_FA;
const int PlayerStatus_Status_Status_ARRAYSIZE = PlayerStatus_Status_Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* PlayerStatus_Status_descriptor();
inline const ::std::string& PlayerStatus_Status_Name(PlayerStatus_Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    PlayerStatus_Status_descriptor(), value);
}
inline bool PlayerStatus_Status_Parse(
    const ::std::string& name, PlayerStatus_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PlayerStatus_Status>(
    PlayerStatus_Status_descriptor(), name, value);
}
enum GameStatus_Status {
  GameStatus_Status_SCHEDULED = 0,
  GameStatus_Status_PREGAME = 2,
  GameStatus_Status_INGAME = 3,
  GameStatus_Status_POSTGAME = 5,
  GameStatus_Status_CLOSED = 4
};
bool GameStatus_Status_IsValid(int value);
const GameStatus_Status GameStatus_Status_Status_MIN = GameStatus_Status_SCHEDULED;
const GameStatus_Status GameStatus_Status_Status_MAX = GameStatus_Status_POSTGAME;
const int GameStatus_Status_Status_ARRAYSIZE = GameStatus_Status_Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* GameStatus_Status_descriptor();
inline const ::std::string& GameStatus_Status_Name(GameStatus_Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    GameStatus_Status_descriptor(), value);
}
inline bool GameStatus_Status_Parse(
    const ::std::string& name, GameStatus_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GameStatus_Status>(
    GameStatus_Status_descriptor(), name, value);
}
enum GlobalState_State {
  GlobalState_State_OFFSEASON = 10,
  GlobalState_State_INSEASON = 30
};
bool GlobalState_State_IsValid(int value);
const GlobalState_State GlobalState_State_State_MIN = GlobalState_State_OFFSEASON;
const GlobalState_State GlobalState_State_State_MAX = GlobalState_State_INSEASON;
const int GlobalState_State_State_ARRAYSIZE = GlobalState_State_State_MAX + 1;

const ::google::protobuf::EnumDescriptor* GlobalState_State_descriptor();
inline const ::std::string& GlobalState_State_Name(GlobalState_State value) {
  return ::google::protobuf::internal::NameOfEnum(
    GlobalState_State_descriptor(), value);
}
inline bool GlobalState_State_Parse(
    const ::std::string& name, GlobalState_State* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GlobalState_State>(
    GlobalState_State_descriptor(), name, value);
}
enum PlayerGameStatus {
  OUT = 0,
  IN = 1,
  NA = 2
};
bool PlayerGameStatus_IsValid(int value);
const PlayerGameStatus PlayerGameStatus_MIN = OUT;
const PlayerGameStatus PlayerGameStatus_MAX = NA;
const int PlayerGameStatus_ARRAYSIZE = PlayerGameStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* PlayerGameStatus_descriptor();
inline const ::std::string& PlayerGameStatus_Name(PlayerGameStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    PlayerGameStatus_descriptor(), value);
}
inline bool PlayerGameStatus_Parse(
    const ::std::string& name, PlayerGameStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PlayerGameStatus>(
    PlayerGameStatus_descriptor(), name, value);
}
// ===================================================================

class PlayerStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fantasybit.PlayerStatus) */ {
 public:
  PlayerStatus();
  virtual ~PlayerStatus();

  PlayerStatus(const PlayerStatus& from);

  inline PlayerStatus& operator=(const PlayerStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerStatus(PlayerStatus&& from) noexcept
    : PlayerStatus() {
    *this = ::std::move(from);
  }

  inline PlayerStatus& operator=(PlayerStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerStatus* internal_default_instance() {
    return reinterpret_cast<const PlayerStatus*>(
               &_PlayerStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(PlayerStatus* other);
  friend void swap(PlayerStatus& a, PlayerStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  PlayerStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PlayerStatus& from);
  void MergeFrom(const PlayerStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PlayerStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef PlayerStatus_Status Status;
  static const Status ACTIVE =
    PlayerStatus_Status_ACTIVE;
  static const Status INACTIVE =
    PlayerStatus_Status_INACTIVE;
  static const Status OTHER =
    PlayerStatus_Status_OTHER;
  static const Status FA =
    PlayerStatus_Status_FA;
  static inline bool Status_IsValid(int value) {
    return PlayerStatus_Status_IsValid(value);
  }
  static const Status Status_MIN =
    PlayerStatus_Status_Status_MIN;
  static const Status Status_MAX =
    PlayerStatus_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    PlayerStatus_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Status_descriptor() {
    return PlayerStatus_Status_descriptor();
  }
  static inline const ::std::string& Status_Name(Status value) {
    return PlayerStatus_Status_Name(value);
  }
  static inline bool Status_Parse(const ::std::string& name,
      Status* value) {
    return PlayerStatus_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string teamid = 20;
  bool has_teamid() const;
  void clear_teamid();
  static const int kTeamidFieldNumber = 20;
  const ::std::string& teamid() const;
  void set_teamid(const ::std::string& value);
  #if LANG_CXX11
  void set_teamid(::std::string&& value);
  #endif
  void set_teamid(const char* value);
  void set_teamid(const char* value, size_t size);
  ::std::string* mutable_teamid();
  ::std::string* release_teamid();
  void set_allocated_teamid(::std::string* teamid);

  // optional string symbol = 50;
  bool has_symbol() const;
  void clear_symbol();
  static const int kSymbolFieldNumber = 50;
  const ::std::string& symbol() const;
  void set_symbol(const ::std::string& value);
  #if LANG_CXX11
  void set_symbol(::std::string&& value);
  #endif
  void set_symbol(const char* value);
  void set_symbol(const char* value, size_t size);
  ::std::string* mutable_symbol();
  ::std::string* release_symbol();
  void set_allocated_symbol(::std::string* symbol);

  // optional .fantasybit.PlayerResult totals = 40;
  bool has_totals() const;
  void clear_totals();
  static const int kTotalsFieldNumber = 40;
  const ::fantasybit::PlayerResult& totals() const;
  ::fantasybit::PlayerResult* release_totals();
  ::fantasybit::PlayerResult* mutable_totals();
  void set_allocated_totals(::fantasybit::PlayerResult* totals);

  // optional .fantasybit.PlayerStatus.Status status = 30;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 30;
  ::fantasybit::PlayerStatus_Status status() const;
  void set_status(::fantasybit::PlayerStatus_Status value);

  // @@protoc_insertion_point(class_scope:fantasybit.PlayerStatus)
 private:
  void set_has_teamid();
  void clear_has_teamid();
  void set_has_status();
  void clear_has_status();
  void set_has_totals();
  void clear_has_totals();
  void set_has_symbol();
  void clear_has_symbol();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr teamid_;
  ::google::protobuf::internal::ArenaStringPtr symbol_;
  ::fantasybit::PlayerResult* totals_;
  int status_;
  friend struct ::protobuf_StatusData_2eproto::TableStruct;
  friend void ::protobuf_StatusData_2eproto::InitDefaultsPlayerStatusImpl();
};
// -------------------------------------------------------------------

class GameStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fantasybit.GameStatus) */ {
 public:
  GameStatus();
  virtual ~GameStatus();

  GameStatus(const GameStatus& from);

  inline GameStatus& operator=(const GameStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameStatus(GameStatus&& from) noexcept
    : GameStatus() {
    *this = ::std::move(from);
  }

  inline GameStatus& operator=(GameStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameStatus* internal_default_instance() {
    return reinterpret_cast<const GameStatus*>(
               &_GameStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(GameStatus* other);
  friend void swap(GameStatus& a, GameStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  GameStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GameStatus& from);
  void MergeFrom(const GameStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GameStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef GameStatus_Status Status;
  static const Status SCHEDULED =
    GameStatus_Status_SCHEDULED;
  static const Status PREGAME =
    GameStatus_Status_PREGAME;
  static const Status INGAME =
    GameStatus_Status_INGAME;
  static const Status POSTGAME =
    GameStatus_Status_POSTGAME;
  static const Status CLOSED =
    GameStatus_Status_CLOSED;
  static inline bool Status_IsValid(int value) {
    return GameStatus_Status_IsValid(value);
  }
  static const Status Status_MIN =
    GameStatus_Status_Status_MIN;
  static const Status Status_MAX =
    GameStatus_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    GameStatus_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Status_descriptor() {
    return GameStatus_Status_descriptor();
  }
  static inline const ::std::string& Status_Name(Status value) {
    return GameStatus_Status_Name(value);
  }
  static inline bool Status_Parse(const ::std::string& name,
      Status* value) {
    return GameStatus_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .fantasybit.GameStatus.Status status = 10;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 10;
  ::fantasybit::GameStatus_Status status() const;
  void set_status(::fantasybit::GameStatus_Status value);

  // optional uint32 datetime = 20;
  bool has_datetime() const;
  void clear_datetime();
  static const int kDatetimeFieldNumber = 20;
  ::google::protobuf::uint32 datetime() const;
  void set_datetime(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fantasybit.GameStatus)
 private:
  void set_has_status();
  void clear_has_status();
  void set_has_datetime();
  void clear_has_datetime();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int status_;
  ::google::protobuf::uint32 datetime_;
  friend struct ::protobuf_StatusData_2eproto::TableStruct;
  friend void ::protobuf_StatusData_2eproto::InitDefaultsGameStatusImpl();
};
// -------------------------------------------------------------------

class TeamDepth : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fantasybit.TeamDepth) */ {
 public:
  TeamDepth();
  virtual ~TeamDepth();

  TeamDepth(const TeamDepth& from);

  inline TeamDepth& operator=(const TeamDepth& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TeamDepth(TeamDepth&& from) noexcept
    : TeamDepth() {
    *this = ::std::move(from);
  }

  inline TeamDepth& operator=(TeamDepth&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TeamDepth& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TeamDepth* internal_default_instance() {
    return reinterpret_cast<const TeamDepth*>(
               &_TeamDepth_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(TeamDepth* other);
  friend void swap(TeamDepth& a, TeamDepth& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TeamDepth* New() const PROTOBUF_FINAL { return New(NULL); }

  TeamDepth* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TeamDepth& from);
  void MergeFrom(const TeamDepth& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TeamDepth* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string qb = 10;
  int qb_size() const;
  void clear_qb();
  static const int kQbFieldNumber = 10;
  const ::std::string& qb(int index) const;
  ::std::string* mutable_qb(int index);
  void set_qb(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_qb(int index, ::std::string&& value);
  #endif
  void set_qb(int index, const char* value);
  void set_qb(int index, const char* value, size_t size);
  ::std::string* add_qb();
  void add_qb(const ::std::string& value);
  #if LANG_CXX11
  void add_qb(::std::string&& value);
  #endif
  void add_qb(const char* value);
  void add_qb(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& qb() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_qb();

  // repeated string rb = 20;
  int rb_size() const;
  void clear_rb();
  static const int kRbFieldNumber = 20;
  const ::std::string& rb(int index) const;
  ::std::string* mutable_rb(int index);
  void set_rb(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_rb(int index, ::std::string&& value);
  #endif
  void set_rb(int index, const char* value);
  void set_rb(int index, const char* value, size_t size);
  ::std::string* add_rb();
  void add_rb(const ::std::string& value);
  #if LANG_CXX11
  void add_rb(::std::string&& value);
  #endif
  void add_rb(const char* value);
  void add_rb(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& rb() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_rb();

  // repeated string wr = 30;
  int wr_size() const;
  void clear_wr();
  static const int kWrFieldNumber = 30;
  const ::std::string& wr(int index) const;
  ::std::string* mutable_wr(int index);
  void set_wr(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_wr(int index, ::std::string&& value);
  #endif
  void set_wr(int index, const char* value);
  void set_wr(int index, const char* value, size_t size);
  ::std::string* add_wr();
  void add_wr(const ::std::string& value);
  #if LANG_CXX11
  void add_wr(::std::string&& value);
  #endif
  void add_wr(const char* value);
  void add_wr(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& wr() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_wr();

  // repeated string te = 40;
  int te_size() const;
  void clear_te();
  static const int kTeFieldNumber = 40;
  const ::std::string& te(int index) const;
  ::std::string* mutable_te(int index);
  void set_te(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_te(int index, ::std::string&& value);
  #endif
  void set_te(int index, const char* value);
  void set_te(int index, const char* value, size_t size);
  ::std::string* add_te();
  void add_te(const ::std::string& value);
  #if LANG_CXX11
  void add_te(::std::string&& value);
  #endif
  void add_te(const char* value);
  void add_te(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& te() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_te();

  // repeated string k = 50;
  int k_size() const;
  void clear_k();
  static const int kKFieldNumber = 50;
  const ::std::string& k(int index) const;
  ::std::string* mutable_k(int index);
  void set_k(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_k(int index, ::std::string&& value);
  #endif
  void set_k(int index, const char* value);
  void set_k(int index, const char* value, size_t size);
  ::std::string* add_k();
  void add_k(const ::std::string& value);
  #if LANG_CXX11
  void add_k(::std::string&& value);
  #endif
  void add_k(const char* value);
  void add_k(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& k() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_k();

  // @@protoc_insertion_point(class_scope:fantasybit.TeamDepth)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> qb_;
  ::google::protobuf::RepeatedPtrField< ::std::string> rb_;
  ::google::protobuf::RepeatedPtrField< ::std::string> wr_;
  ::google::protobuf::RepeatedPtrField< ::std::string> te_;
  ::google::protobuf::RepeatedPtrField< ::std::string> k_;
  friend struct ::protobuf_StatusData_2eproto::TableStruct;
  friend void ::protobuf_StatusData_2eproto::InitDefaultsTeamDepthImpl();
};
// -------------------------------------------------------------------

class GlobalState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fantasybit.GlobalState) */ {
 public:
  GlobalState();
  virtual ~GlobalState();

  GlobalState(const GlobalState& from);

  inline GlobalState& operator=(const GlobalState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GlobalState(GlobalState&& from) noexcept
    : GlobalState() {
    *this = ::std::move(from);
  }

  inline GlobalState& operator=(GlobalState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GlobalState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GlobalState* internal_default_instance() {
    return reinterpret_cast<const GlobalState*>(
               &_GlobalState_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(GlobalState* other);
  friend void swap(GlobalState& a, GlobalState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GlobalState* New() const PROTOBUF_FINAL { return New(NULL); }

  GlobalState* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GlobalState& from);
  void MergeFrom(const GlobalState& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GlobalState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef GlobalState_State State;
  static const State OFFSEASON =
    GlobalState_State_OFFSEASON;
  static const State INSEASON =
    GlobalState_State_INSEASON;
  static inline bool State_IsValid(int value) {
    return GlobalState_State_IsValid(value);
  }
  static const State State_MIN =
    GlobalState_State_State_MIN;
  static const State State_MAX =
    GlobalState_State_State_MAX;
  static const int State_ARRAYSIZE =
    GlobalState_State_State_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  State_descriptor() {
    return GlobalState_State_descriptor();
  }
  static inline const ::std::string& State_Name(State value) {
    return GlobalState_State_Name(value);
  }
  static inline bool State_Parse(const ::std::string& name,
      State* value) {
    return GlobalState_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional uint32 season = 10;
  bool has_season() const;
  void clear_season();
  static const int kSeasonFieldNumber = 10;
  ::google::protobuf::uint32 season() const;
  void set_season(::google::protobuf::uint32 value);

  // optional uint32 week = 20;
  bool has_week() const;
  void clear_week();
  static const int kWeekFieldNumber = 20;
  ::google::protobuf::uint32 week() const;
  void set_week(::google::protobuf::uint32 value);

  // optional .fantasybit.GlobalState.State state = 1;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 1;
  ::fantasybit::GlobalState_State state() const;
  void set_state(::fantasybit::GlobalState_State value);

  // @@protoc_insertion_point(class_scope:fantasybit.GlobalState)
 private:
  void set_has_state();
  void clear_has_state();
  void set_has_season();
  void clear_has_season();
  void set_has_week();
  void clear_has_week();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 season_;
  ::google::protobuf::uint32 week_;
  int state_;
  friend struct ::protobuf_StatusData_2eproto::TableStruct;
  friend void ::protobuf_StatusData_2eproto::InitDefaultsGlobalStateImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PlayerStatus

// optional string teamid = 20;
inline bool PlayerStatus::has_teamid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerStatus::set_has_teamid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerStatus::clear_has_teamid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerStatus::clear_teamid() {
  teamid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_teamid();
}
inline const ::std::string& PlayerStatus::teamid() const {
  // @@protoc_insertion_point(field_get:fantasybit.PlayerStatus.teamid)
  return teamid_.GetNoArena();
}
inline void PlayerStatus::set_teamid(const ::std::string& value) {
  set_has_teamid();
  teamid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fantasybit.PlayerStatus.teamid)
}
#if LANG_CXX11
inline void PlayerStatus::set_teamid(::std::string&& value) {
  set_has_teamid();
  teamid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.PlayerStatus.teamid)
}
#endif
inline void PlayerStatus::set_teamid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_teamid();
  teamid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fantasybit.PlayerStatus.teamid)
}
inline void PlayerStatus::set_teamid(const char* value, size_t size) {
  set_has_teamid();
  teamid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fantasybit.PlayerStatus.teamid)
}
inline ::std::string* PlayerStatus::mutable_teamid() {
  set_has_teamid();
  // @@protoc_insertion_point(field_mutable:fantasybit.PlayerStatus.teamid)
  return teamid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PlayerStatus::release_teamid() {
  // @@protoc_insertion_point(field_release:fantasybit.PlayerStatus.teamid)
  clear_has_teamid();
  return teamid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlayerStatus::set_allocated_teamid(::std::string* teamid) {
  if (teamid != NULL) {
    set_has_teamid();
  } else {
    clear_has_teamid();
  }
  teamid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), teamid);
  // @@protoc_insertion_point(field_set_allocated:fantasybit.PlayerStatus.teamid)
}

// optional .fantasybit.PlayerStatus.Status status = 30;
inline bool PlayerStatus::has_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerStatus::set_has_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerStatus::clear_has_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerStatus::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::fantasybit::PlayerStatus_Status PlayerStatus::status() const {
  // @@protoc_insertion_point(field_get:fantasybit.PlayerStatus.status)
  return static_cast< ::fantasybit::PlayerStatus_Status >(status_);
}
inline void PlayerStatus::set_status(::fantasybit::PlayerStatus_Status value) {
  assert(::fantasybit::PlayerStatus_Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:fantasybit.PlayerStatus.status)
}

// optional .fantasybit.PlayerResult totals = 40;
inline bool PlayerStatus::has_totals() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerStatus::set_has_totals() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerStatus::clear_has_totals() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::fantasybit::PlayerResult& PlayerStatus::totals() const {
  const ::fantasybit::PlayerResult* p = totals_;
  // @@protoc_insertion_point(field_get:fantasybit.PlayerStatus.totals)
  return p != NULL ? *p : *reinterpret_cast<const ::fantasybit::PlayerResult*>(
      &::fantasybit::_PlayerResult_default_instance_);
}
inline ::fantasybit::PlayerResult* PlayerStatus::release_totals() {
  // @@protoc_insertion_point(field_release:fantasybit.PlayerStatus.totals)
  clear_has_totals();
  ::fantasybit::PlayerResult* temp = totals_;
  totals_ = NULL;
  return temp;
}
inline ::fantasybit::PlayerResult* PlayerStatus::mutable_totals() {
  set_has_totals();
  if (totals_ == NULL) {
    totals_ = new ::fantasybit::PlayerResult;
  }
  // @@protoc_insertion_point(field_mutable:fantasybit.PlayerStatus.totals)
  return totals_;
}
inline void PlayerStatus::set_allocated_totals(::fantasybit::PlayerResult* totals) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(totals_);
  }
  if (totals) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      totals = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, totals, submessage_arena);
    }
    set_has_totals();
  } else {
    clear_has_totals();
  }
  totals_ = totals;
  // @@protoc_insertion_point(field_set_allocated:fantasybit.PlayerStatus.totals)
}

// optional string symbol = 50;
inline bool PlayerStatus::has_symbol() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerStatus::set_has_symbol() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerStatus::clear_has_symbol() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerStatus::clear_symbol() {
  symbol_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_symbol();
}
inline const ::std::string& PlayerStatus::symbol() const {
  // @@protoc_insertion_point(field_get:fantasybit.PlayerStatus.symbol)
  return symbol_.GetNoArena();
}
inline void PlayerStatus::set_symbol(const ::std::string& value) {
  set_has_symbol();
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fantasybit.PlayerStatus.symbol)
}
#if LANG_CXX11
inline void PlayerStatus::set_symbol(::std::string&& value) {
  set_has_symbol();
  symbol_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.PlayerStatus.symbol)
}
#endif
inline void PlayerStatus::set_symbol(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_symbol();
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fantasybit.PlayerStatus.symbol)
}
inline void PlayerStatus::set_symbol(const char* value, size_t size) {
  set_has_symbol();
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fantasybit.PlayerStatus.symbol)
}
inline ::std::string* PlayerStatus::mutable_symbol() {
  set_has_symbol();
  // @@protoc_insertion_point(field_mutable:fantasybit.PlayerStatus.symbol)
  return symbol_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PlayerStatus::release_symbol() {
  // @@protoc_insertion_point(field_release:fantasybit.PlayerStatus.symbol)
  clear_has_symbol();
  return symbol_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlayerStatus::set_allocated_symbol(::std::string* symbol) {
  if (symbol != NULL) {
    set_has_symbol();
  } else {
    clear_has_symbol();
  }
  symbol_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), symbol);
  // @@protoc_insertion_point(field_set_allocated:fantasybit.PlayerStatus.symbol)
}

// -------------------------------------------------------------------

// GameStatus

// optional .fantasybit.GameStatus.Status status = 10;
inline bool GameStatus::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameStatus::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameStatus::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameStatus::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::fantasybit::GameStatus_Status GameStatus::status() const {
  // @@protoc_insertion_point(field_get:fantasybit.GameStatus.status)
  return static_cast< ::fantasybit::GameStatus_Status >(status_);
}
inline void GameStatus::set_status(::fantasybit::GameStatus_Status value) {
  assert(::fantasybit::GameStatus_Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:fantasybit.GameStatus.status)
}

// optional uint32 datetime = 20;
inline bool GameStatus::has_datetime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameStatus::set_has_datetime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameStatus::clear_has_datetime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameStatus::clear_datetime() {
  datetime_ = 0u;
  clear_has_datetime();
}
inline ::google::protobuf::uint32 GameStatus::datetime() const {
  // @@protoc_insertion_point(field_get:fantasybit.GameStatus.datetime)
  return datetime_;
}
inline void GameStatus::set_datetime(::google::protobuf::uint32 value) {
  set_has_datetime();
  datetime_ = value;
  // @@protoc_insertion_point(field_set:fantasybit.GameStatus.datetime)
}

// -------------------------------------------------------------------

// TeamDepth

// repeated string qb = 10;
inline int TeamDepth::qb_size() const {
  return qb_.size();
}
inline void TeamDepth::clear_qb() {
  qb_.Clear();
}
inline const ::std::string& TeamDepth::qb(int index) const {
  // @@protoc_insertion_point(field_get:fantasybit.TeamDepth.qb)
  return qb_.Get(index);
}
inline ::std::string* TeamDepth::mutable_qb(int index) {
  // @@protoc_insertion_point(field_mutable:fantasybit.TeamDepth.qb)
  return qb_.Mutable(index);
}
inline void TeamDepth::set_qb(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:fantasybit.TeamDepth.qb)
  qb_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void TeamDepth::set_qb(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:fantasybit.TeamDepth.qb)
  qb_.Mutable(index)->assign(std::move(value));
}
#endif
inline void TeamDepth::set_qb(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  qb_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:fantasybit.TeamDepth.qb)
}
inline void TeamDepth::set_qb(int index, const char* value, size_t size) {
  qb_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fantasybit.TeamDepth.qb)
}
inline ::std::string* TeamDepth::add_qb() {
  // @@protoc_insertion_point(field_add_mutable:fantasybit.TeamDepth.qb)
  return qb_.Add();
}
inline void TeamDepth::add_qb(const ::std::string& value) {
  qb_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:fantasybit.TeamDepth.qb)
}
#if LANG_CXX11
inline void TeamDepth::add_qb(::std::string&& value) {
  qb_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:fantasybit.TeamDepth.qb)
}
#endif
inline void TeamDepth::add_qb(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  qb_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:fantasybit.TeamDepth.qb)
}
inline void TeamDepth::add_qb(const char* value, size_t size) {
  qb_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:fantasybit.TeamDepth.qb)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TeamDepth::qb() const {
  // @@protoc_insertion_point(field_list:fantasybit.TeamDepth.qb)
  return qb_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TeamDepth::mutable_qb() {
  // @@protoc_insertion_point(field_mutable_list:fantasybit.TeamDepth.qb)
  return &qb_;
}

// repeated string rb = 20;
inline int TeamDepth::rb_size() const {
  return rb_.size();
}
inline void TeamDepth::clear_rb() {
  rb_.Clear();
}
inline const ::std::string& TeamDepth::rb(int index) const {
  // @@protoc_insertion_point(field_get:fantasybit.TeamDepth.rb)
  return rb_.Get(index);
}
inline ::std::string* TeamDepth::mutable_rb(int index) {
  // @@protoc_insertion_point(field_mutable:fantasybit.TeamDepth.rb)
  return rb_.Mutable(index);
}
inline void TeamDepth::set_rb(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:fantasybit.TeamDepth.rb)
  rb_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void TeamDepth::set_rb(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:fantasybit.TeamDepth.rb)
  rb_.Mutable(index)->assign(std::move(value));
}
#endif
inline void TeamDepth::set_rb(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  rb_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:fantasybit.TeamDepth.rb)
}
inline void TeamDepth::set_rb(int index, const char* value, size_t size) {
  rb_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fantasybit.TeamDepth.rb)
}
inline ::std::string* TeamDepth::add_rb() {
  // @@protoc_insertion_point(field_add_mutable:fantasybit.TeamDepth.rb)
  return rb_.Add();
}
inline void TeamDepth::add_rb(const ::std::string& value) {
  rb_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:fantasybit.TeamDepth.rb)
}
#if LANG_CXX11
inline void TeamDepth::add_rb(::std::string&& value) {
  rb_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:fantasybit.TeamDepth.rb)
}
#endif
inline void TeamDepth::add_rb(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  rb_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:fantasybit.TeamDepth.rb)
}
inline void TeamDepth::add_rb(const char* value, size_t size) {
  rb_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:fantasybit.TeamDepth.rb)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TeamDepth::rb() const {
  // @@protoc_insertion_point(field_list:fantasybit.TeamDepth.rb)
  return rb_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TeamDepth::mutable_rb() {
  // @@protoc_insertion_point(field_mutable_list:fantasybit.TeamDepth.rb)
  return &rb_;
}

// repeated string wr = 30;
inline int TeamDepth::wr_size() const {
  return wr_.size();
}
inline void TeamDepth::clear_wr() {
  wr_.Clear();
}
inline const ::std::string& TeamDepth::wr(int index) const {
  // @@protoc_insertion_point(field_get:fantasybit.TeamDepth.wr)
  return wr_.Get(index);
}
inline ::std::string* TeamDepth::mutable_wr(int index) {
  // @@protoc_insertion_point(field_mutable:fantasybit.TeamDepth.wr)
  return wr_.Mutable(index);
}
inline void TeamDepth::set_wr(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:fantasybit.TeamDepth.wr)
  wr_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void TeamDepth::set_wr(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:fantasybit.TeamDepth.wr)
  wr_.Mutable(index)->assign(std::move(value));
}
#endif
inline void TeamDepth::set_wr(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  wr_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:fantasybit.TeamDepth.wr)
}
inline void TeamDepth::set_wr(int index, const char* value, size_t size) {
  wr_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fantasybit.TeamDepth.wr)
}
inline ::std::string* TeamDepth::add_wr() {
  // @@protoc_insertion_point(field_add_mutable:fantasybit.TeamDepth.wr)
  return wr_.Add();
}
inline void TeamDepth::add_wr(const ::std::string& value) {
  wr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:fantasybit.TeamDepth.wr)
}
#if LANG_CXX11
inline void TeamDepth::add_wr(::std::string&& value) {
  wr_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:fantasybit.TeamDepth.wr)
}
#endif
inline void TeamDepth::add_wr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  wr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:fantasybit.TeamDepth.wr)
}
inline void TeamDepth::add_wr(const char* value, size_t size) {
  wr_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:fantasybit.TeamDepth.wr)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TeamDepth::wr() const {
  // @@protoc_insertion_point(field_list:fantasybit.TeamDepth.wr)
  return wr_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TeamDepth::mutable_wr() {
  // @@protoc_insertion_point(field_mutable_list:fantasybit.TeamDepth.wr)
  return &wr_;
}

// repeated string te = 40;
inline int TeamDepth::te_size() const {
  return te_.size();
}
inline void TeamDepth::clear_te() {
  te_.Clear();
}
inline const ::std::string& TeamDepth::te(int index) const {
  // @@protoc_insertion_point(field_get:fantasybit.TeamDepth.te)
  return te_.Get(index);
}
inline ::std::string* TeamDepth::mutable_te(int index) {
  // @@protoc_insertion_point(field_mutable:fantasybit.TeamDepth.te)
  return te_.Mutable(index);
}
inline void TeamDepth::set_te(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:fantasybit.TeamDepth.te)
  te_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void TeamDepth::set_te(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:fantasybit.TeamDepth.te)
  te_.Mutable(index)->assign(std::move(value));
}
#endif
inline void TeamDepth::set_te(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  te_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:fantasybit.TeamDepth.te)
}
inline void TeamDepth::set_te(int index, const char* value, size_t size) {
  te_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fantasybit.TeamDepth.te)
}
inline ::std::string* TeamDepth::add_te() {
  // @@protoc_insertion_point(field_add_mutable:fantasybit.TeamDepth.te)
  return te_.Add();
}
inline void TeamDepth::add_te(const ::std::string& value) {
  te_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:fantasybit.TeamDepth.te)
}
#if LANG_CXX11
inline void TeamDepth::add_te(::std::string&& value) {
  te_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:fantasybit.TeamDepth.te)
}
#endif
inline void TeamDepth::add_te(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  te_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:fantasybit.TeamDepth.te)
}
inline void TeamDepth::add_te(const char* value, size_t size) {
  te_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:fantasybit.TeamDepth.te)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TeamDepth::te() const {
  // @@protoc_insertion_point(field_list:fantasybit.TeamDepth.te)
  return te_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TeamDepth::mutable_te() {
  // @@protoc_insertion_point(field_mutable_list:fantasybit.TeamDepth.te)
  return &te_;
}

// repeated string k = 50;
inline int TeamDepth::k_size() const {
  return k_.size();
}
inline void TeamDepth::clear_k() {
  k_.Clear();
}
inline const ::std::string& TeamDepth::k(int index) const {
  // @@protoc_insertion_point(field_get:fantasybit.TeamDepth.k)
  return k_.Get(index);
}
inline ::std::string* TeamDepth::mutable_k(int index) {
  // @@protoc_insertion_point(field_mutable:fantasybit.TeamDepth.k)
  return k_.Mutable(index);
}
inline void TeamDepth::set_k(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:fantasybit.TeamDepth.k)
  k_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void TeamDepth::set_k(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:fantasybit.TeamDepth.k)
  k_.Mutable(index)->assign(std::move(value));
}
#endif
inline void TeamDepth::set_k(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  k_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:fantasybit.TeamDepth.k)
}
inline void TeamDepth::set_k(int index, const char* value, size_t size) {
  k_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fantasybit.TeamDepth.k)
}
inline ::std::string* TeamDepth::add_k() {
  // @@protoc_insertion_point(field_add_mutable:fantasybit.TeamDepth.k)
  return k_.Add();
}
inline void TeamDepth::add_k(const ::std::string& value) {
  k_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:fantasybit.TeamDepth.k)
}
#if LANG_CXX11
inline void TeamDepth::add_k(::std::string&& value) {
  k_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:fantasybit.TeamDepth.k)
}
#endif
inline void TeamDepth::add_k(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  k_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:fantasybit.TeamDepth.k)
}
inline void TeamDepth::add_k(const char* value, size_t size) {
  k_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:fantasybit.TeamDepth.k)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TeamDepth::k() const {
  // @@protoc_insertion_point(field_list:fantasybit.TeamDepth.k)
  return k_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TeamDepth::mutable_k() {
  // @@protoc_insertion_point(field_mutable_list:fantasybit.TeamDepth.k)
  return &k_;
}

// -------------------------------------------------------------------

// GlobalState

// optional .fantasybit.GlobalState.State state = 1;
inline bool GlobalState::has_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GlobalState::set_has_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GlobalState::clear_has_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GlobalState::clear_state() {
  state_ = 10;
  clear_has_state();
}
inline ::fantasybit::GlobalState_State GlobalState::state() const {
  // @@protoc_insertion_point(field_get:fantasybit.GlobalState.state)
  return static_cast< ::fantasybit::GlobalState_State >(state_);
}
inline void GlobalState::set_state(::fantasybit::GlobalState_State value) {
  assert(::fantasybit::GlobalState_State_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:fantasybit.GlobalState.state)
}

// optional uint32 season = 10;
inline bool GlobalState::has_season() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GlobalState::set_has_season() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GlobalState::clear_has_season() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GlobalState::clear_season() {
  season_ = 0u;
  clear_has_season();
}
inline ::google::protobuf::uint32 GlobalState::season() const {
  // @@protoc_insertion_point(field_get:fantasybit.GlobalState.season)
  return season_;
}
inline void GlobalState::set_season(::google::protobuf::uint32 value) {
  set_has_season();
  season_ = value;
  // @@protoc_insertion_point(field_set:fantasybit.GlobalState.season)
}

// optional uint32 week = 20;
inline bool GlobalState::has_week() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GlobalState::set_has_week() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GlobalState::clear_has_week() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GlobalState::clear_week() {
  week_ = 0u;
  clear_has_week();
}
inline ::google::protobuf::uint32 GlobalState::week() const {
  // @@protoc_insertion_point(field_get:fantasybit.GlobalState.week)
  return week_;
}
inline void GlobalState::set_week(::google::protobuf::uint32 value) {
  set_has_week();
  week_ = value;
  // @@protoc_insertion_point(field_set:fantasybit.GlobalState.week)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace fantasybit

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::fantasybit::PlayerStatus_Status> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fantasybit::PlayerStatus_Status>() {
  return ::fantasybit::PlayerStatus_Status_descriptor();
}
template <> struct is_proto_enum< ::fantasybit::GameStatus_Status> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fantasybit::GameStatus_Status>() {
  return ::fantasybit::GameStatus_Status_descriptor();
}
template <> struct is_proto_enum< ::fantasybit::GlobalState_State> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fantasybit::GlobalState_State>() {
  return ::fantasybit::GlobalState_State_descriptor();
}
template <> struct is_proto_enum< ::fantasybit::PlayerGameStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fantasybit::PlayerGameStatus>() {
  return ::fantasybit::PlayerGameStatus_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_StatusData_2eproto__INCLUDED
